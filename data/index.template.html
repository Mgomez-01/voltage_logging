<!DOCTYPE html>
<html>
<head>
    <title>ESP8266 Dual Sensor Logger with Heater Control</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .header { text-align: center; margin-bottom: 30px; color: #333; }
        .controls { text-align: center; margin-bottom: 20px; }
        .btn { background-color: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin: 0 5px; text-decoration: none; display: inline-block; }
        .btn:hover { background-color: #45a049; }
        .btn.danger { background-color: #f44336; }
        .btn.danger:hover { background-color: #da190b; }
        .btn.warning { background-color: #ff9800; }
        .btn.warning:hover { background-color: #e68900; }
        .btn:disabled { background-color: #cccccc; cursor: not-allowed; }
        .status { text-align: center; margin-bottom: 20px; padding: 10px; border-radius: 4px; }
        .status.connected { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.disconnected { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .chart-container { width: 100%; height: 400px; margin-bottom: 30px; }
        .log-container { height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; background-color: #f9f9f9; font-family: monospace; font-size: 12px; }
        .current-readings { text-align: center; margin-bottom: 20px; }
        .reading { display: inline-block; margin: 0 20px; padding: 15px; background-color: #f8f9fa; border-radius: 8px; border: 2px solid #dee2e6; }
        .reading-value { font-size: 24px; font-weight: bold; color: #2196F3; }
        .reading-label { font-size: 14px; color: #666; margin-top: 5px; }
        .stats { display: flex; justify-content: space-around; margin-bottom: 20px; flex-wrap: wrap; }
        .stat { text-align: center; margin: 5px; }
        .stat-value { font-size: 18px; font-weight: bold; color: #4CAF50; }
        .stat-label { font-size: 12px; color: #666; }
        .debug { background-color: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 4px; font-family: monospace; font-size: 12px; }
        .control-panel { background-color: #f8f9fa; border: 2px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0; }
        .control-panel h3 { margin-top: 0; color: #495057; }
        .heater-status { display: inline-block; width: 20px; height: 20px; border-radius: 50%; margin-left: 10px; vertical-align: middle; }
        .heater-on { background-color: #ff4444; box-shadow: 0 0 10px #ff4444; }
        .heater-off { background-color: #666666; }
        .pid-params { margin-top: 10px; }
        .pid-params input { width: 60px; margin: 0 5px; padding: 5px; border: 1px solid #ccc; border-radius: 4px; }
        .temp-input { width: 80px; padding: 5px; margin: 0 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px; }
        .debug-enhanced { background-color: #e3f2fd; border: 2px solid #2196f3; padding: 15px; margin: 10px 0; border-radius: 8px; font-family: monospace; font-size: 11px; max-height: 150px; overflow-y: auto; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ESP8266 Dual Sensor Logger with Heater Control</h1>
            <p>Real-time voltage and temperature monitoring with PID heater control</p>
        </div>

        <div class="debug">
            <strong>Basic Info:</strong><br>
            ESP8266 IP: {{WIFI_IP}} | WebSocket Port: 81 | ADC Pin: A0 (pin {{ADC_PIN_NUM}})<br>
            Channel 0: Voltage Sensor | Channel 1: 100k Thermistor | Heater Relay: GPIO16 (D0)<br>
            Uptime: <span id="uptime">0</span>s | Chart: <span id="chartStatus">Checking...</span> | Logging: <span id="loggingStatus">{{LOGGING_STATUS_TEXT_INITIAL}}</span>
        </div>

        <div class="debug-enhanced" id="connectionDebugPanel">
            <strong>üîß CONNECTION DEBUG:</strong><br>
            <div id="detailedDebug">Initializing connection diagnostics...</div>
        </div>

        <div style="text-align:center;margin:20px 0;padding:20px;background-color:#f8f9fa;border-radius:8px;border:2px solid #dee2e6;">
            <h3 style="margin-top:0;color:#495057;">Data Logging Control</h3>
            <div style="font-size:18px;margin:10px 0;">Status: <span id="mainLoggingStatus" style="font-weight:bold;color:{{LOGGING_STATUS_COLOR_INITIAL}};">{{LOGGING_STATUS_TEXT_INITIAL}}</span></div>
            <button onclick="startLogging()" class="btn" id="startBtn" style="background-color:#28a745;margin:5px;" {{START_LOGGING_DISABLED_ATTR}}>‚ñ∂ Start Logging</button>
            <button onclick="stopLogging()" class="btn" id="stopBtn" style="background-color:#dc3545;margin:5px;" {{STOP_LOGGING_DISABLED_ATTR}}>‚è∏ Stop Logging</button>
            <button onclick="testConnection()" class="btn" style="background-color:#17a2b8;margin:5px;">üîß Test Connection</button>
            <div style="font-size:14px;color:#6c757d;margin-top:10px;">{{LOGGING_DESCRIPTION_INITIAL}}</div>
        </div>

        <div id="status" class="status disconnected">Connecting to WebSocket...</div>

        <div class="control-panel">
            <h3>üî• Heater Control</h3>
            <div style="margin-bottom: 15px;">
                Relay Status: <span id="relayStatus" style="font-weight: bold;">{{RELAY_STATUS_TEXT_INITIAL}}</span>
                <span id="heaterIndicator" class="heater-status {{HEATER_INDICATOR_CLASS_INITIAL}}"></span>
            </div>
            <div style="margin-bottom: 15px;">
                Runtime: <span id="heaterRuntime">0:00:00</span>
                | Safety Timeout: 10 minutes
            </div>
            <button onclick="relayOn()" class="btn" id="relayOnBtn">üî• Turn ON</button>
            <button onclick="relayOff()" class="btn danger" id="relayOffBtn">‚èπ Turn OFF</button>
            <button onclick="emergencyStop()" class="btn danger" style="margin-left: 20px;">‚ö†Ô∏è EMERGENCY STOP</button>
        </div>

        <div class="control-panel">
            <h3>üå°Ô∏è Temperature Control</h3>
            <div style="margin-bottom: 15px;">
                Current: <span id="currentTemp" style="font-size: 20px; font-weight: bold; color: #2196F3;">--</span>¬∞C
                | Target: <input type="number" id="targetTempInput" class="temp-input" value="{{TARGET_TEMP_INITIAL}}" min="0" max="{{MAX_SAFE_TEMP_VALUE}}" step="0.5">
                <button onclick="setTargetTemp()" class="btn" style="padding: 5px 15px;">Set</button>
            </div>
            <div style="margin-bottom: 15px;">
                PID Control: <span id="pidStatus" style="font-weight: bold;">{{PID_STATUS_TEXT_INITIAL}}</span>
                | Output: <span id="pidOutputValue">{{PID_OUTPUT_INITIAL}}</span>%
            </div>
            <button onclick="enablePID()" class="btn" id="pidEnableBtn">‚ñ∂ Enable PID</button>
            <button onclick="disablePID()" class="btn warning" id="pidDisableBtn">‚è∏ Manual Mode</button>
            <div class="pid-params">
                <strong>PID Parameters:</strong>
                Kp: <input type="number" id="kpInput" value="{{PID_KP_INITIAL}}" step="0.1">
                Ki: <input type="number" id="kiInput" value="{{PID_KI_INITIAL}}" step="0.1">
                Kd: <input type="number" id="kdInput" value="{{PID_KD_INITIAL}}" step="0.1">
                <button onclick="updatePIDParams()" class="btn" style="margin-left: 10px;">Update</button>
            </div>
        </div>

        <div class="current-readings">
            <div class="reading">
                <div class="reading-value" id="currentVoltage">--</div>
                <div class="reading-label">Voltage (V)</div>
            </div>
            <div class="reading">
                <div class="reading-value" id="currentTemperature">--</div>
                <div class="reading-label">Temperature (¬∞C)</div>
            </div>
        </div>

        <div class="stats">
            <div class="stat"><div class="stat-value" id="minVoltage">--</div><div class="stat-label">Min Voltage (V)</div></div>
            <div class="stat"><div class="stat-value" id="maxVoltage">--</div><div class="stat-label">Max Voltage (V)</div></div>
            <div class="stat"><div class="stat-value" id="avgVoltage">--</div><div class="stat-label">Avg Voltage (V)</div></div>
            <div class="stat"><div class="stat-value" id="minTemperature">--</div><div class="stat-label">Min Temp (¬∞C)</div></div>
            <div class="stat"><div class="stat-value" id="maxTemperature">--</div><div class="stat-label">Max Temp (¬∞C)</div></div>
            <div class="stat"><div class="stat-value" id="avgTemperature">--</div><div class="stat-label">Avg Temp (¬∞C)</div></div>
            <div class="stat"><div class="stat-value" id="sampleCount">0</div><div class="stat-label">Samples</div></div>
        </div>

        <div class="controls">
            <a href="/data.csv" class="btn">Download Data</a>
            <button onclick="clearData()" class="btn danger">Clear Data</button>
            </div>

        <div class="chart-container"><canvas id="sensorChart"></canvas></div>
        <div class="log-container" id="logContainer"><div>Sensor readings will appear here...</div></div>
    </div>

    <script>
        let ws, chart, startTime = Date.now();
        // **FIX:** Changed 'loggingEnabled' to 'displayLoggingEnabled' to avoid confusion
        // It now *only* controls if we *show* logs/chart updates, not *backend* logging.
        let displayLoggingEnabled = true;
        let connectionAttempts = 0, lastMessageTime = 0, maxRetries = 3;
        let voltageStats = { min: Infinity, max: -Infinity, sum: 0, count: 0 };
        let tempStats = { min: Infinity, max: -Infinity, sum: 0, count: 0 };
        let heaterState = {{JS_HEATER_STATE_INITIAL}}; // Boolean
        let pidEnabled = {{JS_PID_ENABLED_INITIAL}};   // Boolean
        let heaterStartTime = 0;
        let pollingActive = false;
        let pollingInterval = null;
        let connectionMode = 'initializing';
        // **FIX:** Added variable to track server-side logging state
        let serverLoggingState = (document.getElementById('loggingStatus').textContent === 'ACTIVE');

        function updateDetailedDebug(msg) {
            const debugEl = document.getElementById('detailedDebug');
            const timestamp = new Date().toLocaleTimeString();
            debugEl.innerHTML += '<br>' + timestamp + ': ' + msg;
            debugEl.scrollTop = debugEl.scrollHeight;
            console.log('[DEBUG] ' + msg);
        }

        function logDebug(msg) {
            console.log('[DEBUG] ' + msg);
            updateDetailedDebug(msg);
        }

        function initChart() {
            logDebug('Checking if Chart.js is available...');
            if (typeof Chart === 'undefined') {
                logDebug('Chart.js not loaded - chart will be disabled');
                document.getElementById('chartStatus').textContent = 'Disabled (no internet)';
                document.getElementById('chartStatus').style.color = 'orange';
                document.getElementById('sensorChart').style.display = 'none';
                const chartContainer = document.querySelector('.chart-container');
                if (chartContainer) chartContainer.innerHTML = '<div style="text-align:center;padding:20px;background:#f0f0f0;border-radius:4px;color:#666;"><strong>Real-time Chart Unavailable</strong><br>Chart.js requires internet connection<br>Sensor readings still work below</div>';
                return;
            }
            logDebug('Chart.js loaded successfully, initializing dual sensor chart...');
            try {
                const ctx = document.getElementById('sensorChart').getContext('2d');
                chart = new Chart(ctx, {
                    type: 'line',
                    data: { labels: [], datasets: [
                        { label: 'Voltage (V)', data: [], borderColor: '#2196F3', backgroundColor: 'rgba(33, 150, 243, 0.1)', borderWidth: 2, fill: false, yAxisID: 'voltage' },
                        { label: 'Temperature (¬∞C)', data: [], borderColor: '#FF6384', backgroundColor: 'rgba(255, 99, 132, 0.1)', borderWidth: 2, fill: false, yAxisID: 'temperature' }
                    ] },
                    options: { responsive: true, maintainAspectRatio: false, scales: {
                        x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Time (ms)' } },
                        voltage: { type: 'linear', position: 'left', title: { display: true, text: 'Voltage (V)' }, min: 0, max: 1 },
                        temperature: { type: 'linear', position: 'right', title: { display: true, text: 'Temperature (¬∞C)' } }
                    }, plugins: { legend: { display: true } }, animation: { duration: 0 } }
                });
                document.getElementById('chartStatus').textContent = 'Active (Dual Sensor)';
                document.getElementById('chartStatus').style.color = 'green';
                logDebug('Dual sensor chart initialized successfully');
            } catch(e) {
                logDebug('Error initializing chart: ' + e.message);
                document.getElementById('chartStatus').textContent = 'Error: ' + e.message;
                document.getElementById('chartStatus').style.color = 'red';
                chart = null;
            }
        }

        function initWebSocket() {
            if (connectionAttempts >= maxRetries) {
                logDebug('Max WebSocket attempts (' + maxRetries + ') reached, switching to HTTP polling');
                connectionMode = 'polling';
                document.getElementById('status').textContent = 'Using HTTP Polling (WebSocket failed after ' + maxRetries + ' attempts)';
                document.getElementById('status').className = 'status connected';
                startPolling();
                return;
            }

            connectionAttempts++;
            connectionMode = 'websocket_attempt_' + connectionAttempts;
            logDebug('WebSocket connection attempt #' + connectionAttempts + '/' + maxRetries);

            const hostname = window.location.hostname;
            const wsUrl = 'ws://' + hostname + ':81';
            logDebug('Hostname: ' + hostname + ', WebSocket URL: ' + wsUrl + ', Page URL: ' + window.location.href);

            try {
                ws = new WebSocket(wsUrl);
                logDebug('WebSocket object created, waiting for connection...');

                const connectionTimeout = setTimeout(() => {
                    logDebug('WebSocket connection timeout after 2 seconds');
                    if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
                        ws.close();
                    }
                    setTimeout(initWebSocket, 500);
                }, 2000);

                ws.onopen = function() {
                    clearTimeout(connectionTimeout);
                    logDebug('‚úÖ WebSocket connected successfully!');
                    connectionMode = 'websocket_connected';
                    document.getElementById('status').textContent = 'WebSocket Connected (Dual Sensor)';
                    document.getElementById('status').className = 'status connected';
                    if(pollingInterval) clearInterval(pollingInterval); // Stop polling if WS connects
                    pollingActive = false;
                };

                ws.onclose = function(event) {
                    clearTimeout(connectionTimeout);
                    logDebug('‚ùå WebSocket closed - Code: ' + event.code + ', Reason: ' + event.reason + ', Clean: ' + event.wasClean);
                    connectionMode = 'websocket_closed';
                    if (connectionAttempts < maxRetries) {
                        document.getElementById('status').textContent = 'Disconnected - Retrying... (' + connectionAttempts + '/' + maxRetries + ')';
                        document.getElementById('status').className = 'status disconnected';
                        setTimeout(initWebSocket, 1000);
                    } else {
                        logDebug('üîÑ Max retries reached, forcing HTTP polling fallback');
                        startPolling();
                    }
                };

                ws.onerror = function(error) {
                    clearTimeout(connectionTimeout);
                    logDebug('‚ùå WebSocket error: ' + JSON.stringify(error));
                    connectionMode = 'websocket_error';
                    document.getElementById('status').textContent = 'WebSocket Error - Retrying...';
                    document.getElementById('status').className = 'status disconnected';
                };

                ws.onmessage = function(event) {
                    lastMessageTime = Date.now();
                    logDebug('üì® WebSocket message: ' + event.data);
                    try {
                        const data = JSON.parse(event.data);
                        // **FIX:** Update serverLoggingState based on WS message
                        if (data.loggingEnabled !== undefined) {
                            serverLoggingState = data.loggingEnabled;
                            updateLoggingStatusUI();
                        }
                        // **FIX:** Only add if server is logging
                        if (serverLoggingState && data.type === 'reading') {
                           addSensorReading(data.timestamp, data.voltage, data.temperature, data);
                        }
                    } catch(e) { logDebug('‚ùå Error parsing message: ' + e.message); }
                };
            } catch(e) {
                logDebug('‚ùå Error creating WebSocket: ' + e.message);
                setTimeout(initWebSocket, 1000);
            }
        }

        function startPolling() {
            if (pollingActive) {
                logDebug('Polling already active, skipping duplicate start');
                return;
            }

            pollingActive = true;
            connectionMode = 'polling';
            logDebug('üîÑ Starting HTTP polling mode (2000ms interval)...');

            document.getElementById('status').textContent = 'Using HTTP Polling (WebSocket failed)';
            document.getElementById('status').className = 'status connected';

            pollingInterval = setInterval(function() {
                logDebug('üîÑ Polling /status endpoint...');
                fetch('/status')
                    .then(function(response) {
                        if (!response.ok) {
                            throw new Error('HTTP ' + response.status + ' ' + response.statusText);
                        }
                        return response.json();
                    })
                    .then(function(data) {
                        logDebug('‚úÖ Polling success: V=' + data.voltage + 'V, T=' + data.temperature + '¬∞C');
                        // **FIX:** Update serverLoggingState based on polling
                        serverLoggingState = data.loggingEnabled;
                        updateLoggingStatusUI();
                        // **FIX:** Only add if server is logging
                        if (serverLoggingState && data.voltage !== undefined && data.temperature !== undefined) {
                            addSensorReading(data.timestamp, data.voltage, data.temperature, data);
                        }
                        document.getElementById('status').textContent = 'HTTP Polling Active (‚úÖ receiving data)';
                        document.getElementById('status').className = 'status connected';
                    })
                    .catch(function(error) {
                        logDebug('‚ùå Polling error: ' + error.message);
                        document.getElementById('status').textContent = 'Polling Error: ' + error.message;
                        document.getElementById('status').className = 'status disconnected';
                    });
            }, 2000);
        }

        function testConnection() {
            logDebug('üîß Manual connection test initiated...');
            fetch('/status')
                .then(response => {
                    if (!response.ok) throw new Error('HTTP ' + response.status);
                    return response.json();
                })
                .then(data => {
                    logDebug('‚úÖ /status test successful: ' + JSON.stringify(data));
                    alert('‚úÖ ESP8266 connection OK!\nVoltage: ' + data.voltage + 'V\nTemperature: ' + data.temperature + '¬∞C');
                })
                .catch(error => {
                    logDebug('‚ùå /status test failed: ' + error.message);
                    alert('‚ùå ESP8266 connection failed: ' + error.message);
                });
        }

        function addSensorReading(timestamp, voltage, temperature, data) {
            document.getElementById('currentVoltage').textContent = voltage.toFixed(4);
            document.getElementById('currentTemperature').textContent = temperature.toFixed(2);
            document.getElementById('currentTemp').textContent = temperature.toFixed(2);

            if (data) {
                updateHeaterStatus(data.heaterState, data.targetTemp, data.pidEnabled, data.pidOutput);
            }

            voltageStats.min = Math.min(voltageStats.min, voltage);
            voltageStats.max = Math.max(voltageStats.max, voltage);
            voltageStats.sum += voltage;
            voltageStats.count++;

            if (temperature > -50 && temperature < 150) {
                tempStats.min = Math.min(tempStats.min, temperature);
                tempStats.max = Math.max(tempStats.max, temperature);
                tempStats.sum += temperature;
                tempStats.count++;
            }

            document.getElementById('minVoltage').textContent = voltageStats.min.toFixed(4);
            document.getElementById('maxVoltage').textContent = voltageStats.max.toFixed(4);
            document.getElementById('avgVoltage').textContent = (voltageStats.sum / voltageStats.count).toFixed(4);
            document.getElementById('sampleCount').textContent = voltageStats.count;

            if (tempStats.count > 0) {
                document.getElementById('minTemperature').textContent = tempStats.min.toFixed(2);
                document.getElementById('maxTemperature').textContent = tempStats.max.toFixed(2);
                document.getElementById('avgTemperature').textContent = (tempStats.sum / tempStats.count).toFixed(2);
            } else {
                document.getElementById('minTemperature').textContent = 'N/A';
                document.getElementById('maxTemperature').textContent = 'N/A';
                document.getElementById('avgTemperature').textContent = 'N/A';
            }

            if (chart && typeof chart.update === 'function') {
                if (chart.data.labels.length > 500) {
                    chart.data.labels.shift();
                    chart.data.datasets[0].data.shift();
                    chart.data.datasets[1].data.shift();
                }
                chart.data.labels.push(timestamp);
                chart.data.datasets[0].data.push(voltage);
                chart.data.datasets[1].data.push(temperature);
                chart.update('none');
            }

            const logContainer = document.getElementById('logContainer');
            const logEntry = document.createElement('div');
            let logText = new Date(timestamp).toLocaleTimeString() + ' - ' + voltage.toFixed(4) + 'V | ' + temperature.toFixed(2) + '¬∞C';
            if (data && data.heaterState !== undefined) {
                logText += ' | Heater: ' + (data.heaterState ? 'ON' : 'OFF');
                if (data.pidEnabled) logText += ' | PID: ' + data.pidOutput.toFixed(1) + '%';
            }
            logEntry.textContent = logText;
            logContainer.appendChild(logEntry);
            while (logContainer.children.length > 100) logContainer.removeChild(logContainer.firstChild);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearData() {
            if (confirm('Are you sure you want to clear all sensor data?')) {
                fetch('/clear').then(function() {
                    if (chart && typeof chart.update === 'function') {
                        chart.data.labels = []; chart.data.datasets[0].data = []; chart.data.datasets[1].data = []; chart.update();
                    }
                    voltageStats = { min: Infinity, max: -Infinity, sum: 0, count: 0 };
                    tempStats = { min: Infinity, max: -Infinity, sum: 0, count: 0 };
                    ['minVoltage', 'maxVoltage', 'avgVoltage', 'minTemperature', 'maxTemperature', 'avgTemperature'].forEach(id => document.getElementById(id).textContent = '--');
                    document.getElementById('sampleCount').textContent = '0';
                    document.getElementById('currentVoltage').textContent = '--';
                    document.getElementById('currentTemperature').textContent = '--';
                    document.getElementById('logContainer').innerHTML = '<div>Data cleared. New sensor readings will appear here...</div>';
                    alert('Sensor data cleared successfully');
                }).catch(function() { alert('Error clearing data'); });
            }
        }

        // **FIX:** Removed toggleLogging function

        function updateLoggingStatusUI() {
            const statusText = serverLoggingState ? 'ACTIVE' : 'PAUSED';
            const statusColor = serverLoggingState ? '#28a745' : '#dc3545';
            document.getElementById('mainLoggingStatus').textContent = statusText;
            document.getElementById('mainLoggingStatus').style.color = statusColor;
            document.getElementById('loggingStatus').textContent = statusText;
            document.getElementById('startBtn').disabled = serverLoggingState;
            document.getElementById('stopBtn').disabled = !serverLoggingState;
        }

        function startLogging() {
            logDebug('Starting dual sensor logging...');
            fetch('/start').then(function(response) {
                return response.text();
            }).then(function(data) {
                logDebug('Start logging response: ' + data);
                serverLoggingState = true;
                updateLoggingStatusUI();
                alert('Dual sensor logging started');
            }).catch(function(error) {
                logDebug('Error starting logging: ' + error.message);
                alert('Error starting logging');
            });
        }

        function stopLogging() {
            logDebug('Stopping dual sensor logging...');
            fetch('/stop').then(function(response) {
                return response.text();
            }).then(function(data) {
                logDebug('Stop logging response: ' + data);
                serverLoggingState = false;
                updateLoggingStatusUI();
                alert('Dual sensor logging stopped');
            }).catch(function(error) {
                logDebug('Error stopping logging: ' + error.message);
                alert('Error stopping logging');
            });
        }

        function updateHeaterStatus(state, target, pidOn, output) {
            heaterState = state;
            pidEnabled = pidOn;
            document.getElementById('relayStatus').textContent = state ? 'ON' : 'OFF';
            document.getElementById('heaterIndicator').className = 'heater-status ' + (state ? 'heater-on' : 'heater-off');
            document.getElementById('pidStatus').textContent = pidOn ? 'ENABLED' : 'DISABLED';
            document.getElementById('pidOutputValue').textContent = output.toFixed(1);
            if (state && heaterStartTime === 0) heaterStartTime = Date.now();
            if (!state) heaterStartTime = 0;
            // Update PID button states
            document.getElementById('pidEnableBtn').disabled = pidEnabled;
            document.getElementById('pidDisableBtn').disabled = !pidEnabled;
        }

        function updateHeaterRuntime() {
            if (heaterState && heaterStartTime > 0) {
                const runtime = Math.floor((Date.now() - heaterStartTime) / 1000);
                const hours = Math.floor(runtime / 3600);
                const minutes = Math.floor((runtime % 3600) / 60);
                const seconds = runtime % 60;
                document.getElementById('heaterRuntime').textContent =
                    hours + ':' + minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
            } else {
                document.getElementById('heaterRuntime').textContent = '0:00:00';
            }
        }

        // ... (Keep other heater control functions) ...
        function relayOn() {
            if (heaterState) { alert('Heater is already ON'); return; }
            if (!confirm('Turn heater ON?')) return;
            logDebug('Turning relay ON...');
            fetch('/relay/on').then(response => response.text()).then(data => {
                logDebug('Relay ON response: ' + data);
                alert('Heater turned ON successfully');
            }).catch(error => {
                logDebug('Error turning relay on: ' + error.message);
                alert('Error: ' + error.message);
            });
        }
        function relayOff() {
            if (!heaterState) { alert('Heater is already OFF'); return; }
            logDebug('Turning relay OFF...');
            fetch('/relay/off').then(response => response.text()).then(data => {
                logDebug('Relay OFF response: ' + data);
                alert('Heater turned OFF successfully');
            }).catch(error => {
                logDebug('Error turning relay off: ' + error.message);
                alert('Error: ' + error.message);
            });
        }
        function emergencyStop() {
            if (!confirm('EMERGENCY STOP: Turn off heater and disable PID?')) return;
            logDebug('EMERGENCY STOP initiated...');
            Promise.all([
                fetch('/relay/off'),
                fetch('/pid/disable')
            ]).then(() => {
                alert('‚ö†Ô∏è EMERGENCY STOP COMPLETE');
            }).catch(error => {
                alert('‚ö†Ô∏è EMERGENCY STOP ERROR: ' + error.message);
            });
        }
        function setTargetTemp() {
            const temp = parseFloat(document.getElementById('targetTempInput').value);
            if (isNaN(temp) || temp < 0 || temp > {{MAX_SAFE_TEMP_VALUE_JS}}) {
                alert('Invalid temperature');
                return;
            }
            fetch('/temp/set?temp=' + temp).then(response => response.text()).then(data => {
                alert('Target temperature set to ' + temp + '¬∞C');
            }).catch(error => alert('Error: ' + error.message));
        }
        function enablePID() {
            if (pidEnabled) { alert('PID already enabled'); return; }
            fetch('/pid/enable').then(response => response.text()).then(data => {
                alert('PID control enabled');
            }).catch(error => alert('Error: ' + error.message));
        }
        function disablePID() {
            if (!pidEnabled) { alert('PID already disabled'); return; }
            fetch('/pid/disable').then(response => response.text()).then(data => {
                alert('PID control disabled');
            }).catch(error => alert('Error: ' + error.message));
        }
        function updatePIDParams() {
            const kp = parseFloat(document.getElementById('kpInput').value);
            const ki = parseFloat(document.getElementById('kiInput').value);
            const kd = parseFloat(document.getElementById('kdInput').value);
            if (isNaN(kp) || isNaN(ki) || isNaN(kd)) {
                alert('Invalid PID parameters');
                return;
            }
            fetch('/pid/params?kp=' + kp + '&ki=' + ki + '&kd=' + kd).then(response => response.text()).then(data => {
                alert('PID parameters updated');
            }).catch(error => alert('Error: ' + error.message));
        }


        window.onload = function() {
            updateDetailedDebug('üöÄ Page loaded, starting initialization...');
            updateDetailedDebug('üîç Testing basic ESP8266 connectivity...');
            fetch('/status')
                .then(response => {
                    if (!response.ok) throw new Error('HTTP ' + response.status);
                    return response.json();
                })
                .then(data => {
                    updateDetailedDebug('‚úÖ Basic connectivity OK! ESP8266 responding.');
                    updateDetailedDebug('üìä Initial readings: V=' + data.voltage + 'V, T=' + data.temperature + '¬∞C');
                    serverLoggingState = data.loggingEnabled; // Set initial state
                    updateLoggingStatusUI(); // Update UI based on initial state
                })
                .catch(error => {
                    updateDetailedDebug('‚ùå Basic connectivity FAILED: ' + error.message);
                    updateDetailedDebug('‚ö†Ô∏è Check ESP8266 connection and try refreshing the page');
                });

            try { initChart(); } catch(e) { logDebug('Chart initialization failed: ' + e.message); }
            logDebug('Starting WebSocket connection process...');
            setTimeout(initWebSocket, 1000);
            setInterval(() => {
                document.getElementById('uptime').textContent = Math.floor((Date.now() - startTime) / 1000);
                updateDetailedDebug('Mode: ' + connectionMode + ' | Attempts: ' + connectionAttempts + '/' + maxRetries + ' | Polling: ' + (pollingActive ? 'YES' : 'NO') + ' | Server Logging: ' + (serverLoggingState ? 'ON':'OFF'));
            }, 5000);
            setInterval(updateHeaterRuntime, 1000);
            updateLoggingStatusUI(); // Ensure buttons are correct on load
            logDebug('‚úÖ Initialization complete');
        };
    </script>
</body>
</html>
